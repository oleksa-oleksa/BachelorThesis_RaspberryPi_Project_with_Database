\chapter{Tätigkeitsbereiche und Aufgaben}
\label{sec:main}
\section{Das Projekt Noise Detector}
\label{sec:main:overview}
Meine Aufgabe während meines Praktikums war die Programmierung der System-Entwicklungs-Board ESP32 DEVKIT. Im Unterschied zu den vorherigen Projekten des Unternehmens Eptecon, die Connectivity-Lösungen für IoT-Geräte darstellen, sollte das neue Projekt \textit{Noise Detector} ein eigenes IoT-Gerät sein, das von Eptecon erfunden wurde und vom mir programmiert. \\\\
Ziel des \textit{Noise Detector} Projekts ist die Entwicklung eines Schallpegelmessgerätes, das zur akustischen Überwachung von Räumen dient und in der Lage ist, aufgrund akustischer Geräusche automatisch einen Alarm auszulösen. Solche Geräte existieren zwar schon lange auf dem Markt sind aber viel teuerer als der Preis, den Eptecon zu seinen Kunden vorschlagen könnte. Das Konstruktionsmerkmal des \textit{Noise Detector} Projekts ist der Tatsache, dass das neue Gerät als ein IoT-Gerät\footnote{https://de.wikipedia.org/wiki/Internet\_der\_Dinge} entwickelt wird und in der Lage sein wird, mit den anderen Geräte und Handy zu kommunizieren. Die Konfiguration eines neuen Gerätes sollte mit Hilfe einer JSON-Datei aus der Cloud erfolgen. \textit{Noise Detector} Projekt sollte auf Basis des Mikrocontrollers ESP32 und eines \textit{Noise Click - Boards} entwickelt werden.

\subsection{Mikrocontroller ESP32}
Die Aufgaben und Programmierung des Mikrocontrollers ESP32 haben mich mit einem neuen Konzept vertraut gemacht. Bisher habe ich während meines Studiums nie über Tensilica Xtensa Mikroprozessor gehört, der ein anpassbarer digitaler Signalprozessor enthält. Der 32-Bit Xtensa Mikroprozessor wird im ESP32 Mikrocontroller verwendet. Weiterhin sind WLAN, Bluetooth, HTTPS-Server und viele weitere Merkmale mit einem schnellen Prozessor integriert, was mit einem unschlagbaren Preis etwa 2,5\$ diesen Mikrocontroller zu einem idealen Lösung in IoT-Bereich macht.\\\\
ESP32 integriert Wi-Fi (2.4 GHz) und Bluetooth 4.2 auf einem einzigen Chip, zusammen mit zwei 32-Bit Xtensa Prozessoren, Ultra-Low-Power-Co-Prozessor und mehreren Peripheriegeräten. Mit der 40-nm-Technologie ist ESP32 ein robustes, hochintegriertes System, das den Anforderungen an Energieeffizienz, kompaktes Design, Sicherheit, hohe Leistung und Zuverlässigkeit gerecht wird. Im Tiefschlaf verbraucht der ESP32 laut Herstellerangabe 2,5 µA. WiFi ist in den Betriebsarten Station, Access Point, Station + Access Point Modus möglich. 32 allgemein verwendbare Ein- und Ausgänge (GPIOs) stehen zur Verfügung, darunter drei UARTs mit Flusssteuerung über Hardware, drei SPI-Schnittstellen, ein CAN-Bus-2.0-Controller, zwei $I^{2}S$-Schnittstellen, zudem 12 analoge Eingänge mit Analog-Digital-Umsetzern bei einer Auflösung von 12 Bit, und zwei analoge Ausgänge mit Digital-Analog-Umsetzern und 10 Bit Auflösung. Jeder GPIO-Port verfügt dabei über Pulsweitenmodulation und Timer-Logik.

Meine Aufgabe war die Programmierung des ESP32 auf einem Entwicklungsboard. Ich musste vorgegeben Board mithilfe C-Programmiersprache so programmieren, dass es in der Lage wird, den Schwellenwert für Geräuscherkennung festzulegen, die Interrupts von Noise Click aufgrund von verschiedenen Benutzereinstellungen zu implementieren und entsprechend zu reagieren und den vorgegebenen Buzz Click anzuschalten. Darüber hinaus sollte ESP32 in lokalen Wi-Fi-Netzwerk angemeldet sein und mithilfe den JSON-Dateien die Einstellungen aus einem Cloud (ThingsBoard / GlueLogics) sowie vom Benutzerabfragen und Benutzer abzufragen und die Information über die Lautstärke im beobachtenden Raum auf Server zu speichern.   

\subsection{Click Boards von Mikroelektronika}
\begin{wrapfigure}{l}{0.4\textwidth}
	\centering
	\fbox{\includegraphics[width=0.3\textwidth]{gfx/noise.png}}
	\caption{Noise Click Board}
	\label{fig:click}
\end{wrapfigure}
MikroElektronika\footnote{https://www.mikroe.com} ist ein Hersteller und Händler von Hardware- und Software-Tools für die Entwicklung eingebetteter Systeme. Die bekanntesten Click-Boards sind eine Hardware-Produktlinie, die aus Hunderten Zusatzboards für die Verbindung von Mikrocontrollern mit Peripherie-Sensoren besteht. Diese Boards verfügen über mikroBUS\footnote{https://download.mikroe.com/documents/standards/mikrobus/mikrobus-standard-specification-v200.pdf}- einen Standard, der von MikroElektronika entwickelt wurde und für die Entwicklung den neuen Board sehr leicht verwendbar ist. 

Noise Click\footnote{https://www.mikroe.com/noise-click} ist eine mikroBUS-Board mit Geräuscherkennungsschaltung. Es ermöglicht, einen Schwellenwert für die Geräuscherkennung für Alarmsysteme, Umgebungsüberwachung oder Datenprotokollierung umzusetzen. Wenn die Lautstärke des Umgebungsgeräuschs den eingestellten Schwellenwert erreicht, wird ein Interrupt ausgelöst. Die wichtigsten Teile der Schaltung sind das Mikrofon, ein RMS-zu-DC Umsetzer, zwei Dual-Rail-to-Rail-Operationsverstärker (Input / Output 10 MHz) und ein 12-Bit-Digital-Analog-Umsetzer (DAC).

BUZZ 2 Click\footnote{https://www.mikroe.com/buzz-2-click} ist ein weiteres Board von MikroElektronika, das ich während meines Praktikum verwendet habe. Dieses Board hat einen magnetischen Summerwandler CMT-8540S-SMT. Die Resonanzfrequenz des Summers beträgt 4 kHz. Das BUZZ 2 Click Board kann entweder mit 3,3 V oder 5 V betrieben werden. Das Funktionsprinzip ist ähnlich zu dem Summer, den man in der Beuth Hochschule im Modul \textit{Maschinenorientierte Programmierung} betrachtet und programmiert hat: mit der Einstellung von Frequenzen kann man die Geräusche am Summer erzeugen. Im Unterschied zum Summer am 8051-Mikrocontroller, den man durch UART-Port programmieren muss, verwendet man bei dem BUZZ 2 Click PWM, um leicht und schnell die Geräusche von verschiedenen Frequenzen am Summer zu erzeugen. 

\section{Vorbereitung}
\label{sec:main:preparation}
Beim ersten Gespräch mit meinem Praktikumsbetreuer Herrn Prizkau informierte ich mich, welche Programmierumgebungen und Programmiersprachen für \textit{"Noise Detector"} Projekt verwendet werden.
Ebenfalls erkundigte ich mich nach der Dokumentation und Dattenblättern der verwendenden Hardware.
\begin{figure}[!hb]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{gfx/esp32_entwick.jpg}}
	\caption[Praktikum Projekt]{Praktikum Projekt: Breadboard mit ESP32, Noise Click und Buzz 2 Click Boards}
	\label{fig:breadboard}
\end{figure}
Als Hardware für meine Programmierungsaufgaben habe ich eine Steckplatine bekommen, auf der mir zur Verfügung ESP32 DEVKIT von Espressif, Noise Click und zwei Clicks Boards von Mikroelektronika sich befanden.

\section{Aufgaben}
Meine Aufgaben waren in folgende Teilbereiche gegliedert:: 
\begin{itemize}
	\item Den Schwellenwert für Noise Click Board berechnen und ihn durch SPI Bus entsprechend programmieren. 
	\item Den Summer durch PWM steuern, einschalten und ausschalten.{\normalsize }
	\item Die Interrupt Service Routine entwickeln, in der ESP32 Board die ankommenden Interrupts bearbeiten und entsprechen reagieren kann:
	\subitem * einen automatischen Alarm mit Hilfe von Summer erzeugen.
	\subitem * einen LED anschalten.
	\subitem * eine Datei auf Cloud Server mit Alarm-Werten schicken.
	\item Wi-Fi  programmieren, JSON-Datei für Input/Output Daten erstellen.
	\item von Cloud Server die entsprechenden JSON Dateien lesen, bearbeiten und Einstellungen des \textit{Noise Detectors} entsprechend der Wünschen des Benutzers ändern.
	\item Anbindung Sensoren/Aktoren an Mikrocontroller testen
	\item Fertigstellung des Schaltplan mithilfe \textit{EAGLE-}Software, Fertigung des Layouts, Bestellung der Platine.
	\item Kurze Projektdokumentation erstellen.	
\end{itemize}

%=====================================================
\subsection{Den Schwellenwert durch SPI Bus setzen}
\label{sec:main:spi}
Meine erste Herausforderung war, SPI Bus zu programmieren und den Schwellwert zu setzen. Obwohl zum Anfang des Praktikums ich schon \textit{Mikrocomputertechnik } bestanden habe, die einige Begriffe ($SPI, I^2C$), die während des Vorstellungsgesprächs erwähnt wurden, waren mir unbekannt und ich brauchte etwas Zeit, um alles zu verstehen. Zuerst sollte man sich mit dem Schaltplan des Noise Clicks vertraut machen, um zu richtig verstehen, wie der Schwellwert der Spannung benutzt werden kann, um Hardware Interrupt zu erzeugen, wenn den Schwellwert übersteigt wird. Der Schaltplan des \textit{Noise Click} Boards steht mit der folgenden Abbildung\footnote{https://download.mikroe.com/documents/add-on-boards/click/noise/noise-click-schematic-v100.pdf} zur Verfügung. 
\begin{figure}[!hb]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{gfx/noise_shematic.png}}
	\caption{MikroElektronika Noise Click Schaltplan}
	\label{fig:noiseShematic}
\end{figure}
Aus dem Datenblatt \textit{MCP4921/4922 12-Bit DAC with SPI Interface}\footnote{http://ww1.microchip.com/downloads/en/devicedoc/21897b.pdf} erkennt man, wie die Ansteuerung richtig zu programmieren ist. Man stellt fest, ob man $DAC_a$ oder $DAC_b$ nehmen will, ob $V_{ref}$ Buffered oder Unbuffered verwendet wird, und ob man die Verstärkung 2 benutzen wird. Meine Wahl hat mir \textit{0111} als Bits 15 - 12  ergeben, was einer dezimal Zahl 7 entspricht. Die restlichen 12 Bits von 16 werden als DAC Data Bits verwendet, indem man die Zahl zwischen 0 und 4095 als $V_{in}$ festlegen kann. Der geschickte Wert Vin erscheint als Analogspannung durch den Verwendeten Spannungsteiler reduziert am Pin $V_{out}$ . Die genau Formel für die Umrechnung findet man auch im Datenblatt und sie lautet:
\begin{equation}
V_{out} = V_{ref} * \frac{Gain * DAC(4096_{max})}{2^{12}}
\end{equation}

Die Spannung $V_{ref}$ muss man in idealen Fall bei jedem DAC mit Digital Multimeter messen und im Programm anpassen, wenn man die exakt genaue Werten bekommen will. Für meinen Fall habe ich fast 2,3V gemessen, obwohl es 2,1V als $V_{ref}$ im Datenblatt angegeben wurde. In der Tat änderten sich die Ausgangswerte nicht dramatisch und konnten übersprungen werden.

Die Spannung $V_{out}$ wird durch einen Spannungsteiler aus den Widerständen R18, R19, R20 wieder reduziert und als $V_{ref}$ am \textit{MCP6022 OpAmp Komparator}\footnote{http://ww1.microchip.com/downloads/en/DeviceDoc/20001685E.pdf} gesetzt. Der Komparator verfügt über zwei Eingänge: einen negativen und einen positiven. An dem negativen Eingang liegt die Spannung $V_{ref}$. An dem positiven Eingang liegt die Spannung $V_{out}$, die aus dem Mikrofon\textit{SPQ0410HR5H}\footnote{https://download.mikroe.com/documents/datasheets/spq0410hr5h-b.pdf} über analoge Vorverarbeitung und weiterhin über den RMC-zu-DC Umsetzer erzeugt wird. 
Dann kommt der Komparator ins Spiel, welcher an seinem Ausgang einen Hardware-Interrupt erzeugt, sobald überstiegt der Wert der ermittelte von Mikrofon Spannung am positiven Eingang den Werte der $V_{ref}$ am negativen Eingang. Das oben beschriebene Verhältnis des Komparators hat man an der Beuth Hochschule im Modul \textit{Analoge Elektronik (Elektrische Systeme III)} gelernt. Somit kann man mit der selbst bestimmten Schwellenwert festlegen, ob man leise oder laute Geräusche erkennen will.  

\subsubsection{Schwierigkeiten und Lösung}
Nachdem mit dem Verständnis der  Hardware der Teil der Aufgabe klar wurde, kam es zu der richtigen Programmierung. Um SPI Bus benutzen zu können, muss man zuerst die GPIO am ESP32 Board definieren, die als Steuerleitungen für die serielle synchrone Datenübertragung gesteuert werden. Um nur einen Schwellwert am \textit{Noise Click} zu setzen und danach nichts mehr durch SPI Bus von \textit{Noise Click} zu bekommen, braucht man nur MOSI Pin (Master Out -> Slave In) zu definieren und die Leitung MISO mit der Zahl \textit{- 1} als nicht benutzt zu markieren. Damit spart man einen GPIO Pin des Mikrocontrollers für zukünftige Anwendungen und Erweiterungen. Bei der GPIO Wahl muss man auch das Datenblatt von ESP32 durchlesen, weil manche GPIOs stehen gar nicht zu Verfügung des Entwicklers, da sie schon innen des ESP32 benutzt werden. Manche GPIOs sind uni-direktional und man muss aufpassen, dass man die Richtung richtig programmiert hat. 

Als ich die alle GPIO Pins in meinem Programm festgelegt hatte und auf Steckplatine die ESP32 Pins mit dem \textit{Noise Click} Pins verbunden habe, durfte ich den Quellcode endlich ausführen. 
Als Erstes wollte ich feststellen, ob der Schwellwert richtig gesetzt wurde. Das kann man am Pin 8 von  \textit{MCP4921/4922 12-Bit DAC with SPI Interface}\footnote{http://ww1.microchip.com/downloads/en/devicedoc/21897b.pdf} mit einem Digitalen Multimeter direkt ermitteln. Dies fand ich sehr spannend, da es zum ersten Mal zu einem reellen Anwendung der ermittelten Kenntnisse in Hardware und Elektrotechnik kam und mir zur Verfügung ein reeler Mikrocontroller stand statt die verschiedene Bauteile, die in Kapseln gelötet wurden. Als ich von mir gesetzte und am Pin 8 erschienene Spannung $V_{ref}$ mit einem Digitalen Multimeter gemessen habe, sollte ich feststellen, dass der Wert überhaupt nicht in der Nähe von gewünschten Bereich war, und ziemlich zufällig aussah. Nach einigen Versuchen den Fehler in Quellcode zu finden, wurde mir von meinem Praktikumsleiter empfohlen, es mit einem Oszilloskop anzuschauen, welche Werte durch SPI vom Mikrocontroller geschickt wurde. Mithilfe des Oszilloskops kann man einen Moment anschauen, wenn durch SPI etwas überträgt wird. Die 16 Bits der Information wurden von ESP32 erzeugt und während der Datenübertragung erscheint eine logische 1 als eine Spannung 3.3V und eine logische 0 als die kleine Spannung 0,2V. Die Abbildung \ref{fig:spi_transfer} zeigt die Übertragung das Steuerwort \textit{0111 0011 1110 1000}, das nach der Fehlerfindung korrigiert wurde. 
\begin{figure}[!hb]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{gfx/spi_transfer.png}}
	\caption{Datenübertragung durch SPI}
	\label{fig:spi_transfer}
\end{figure}

Als der Moment der Datenübertragung eingefangen werden konnte, wurde es klar, dass die ersten 8 Bits des Steuerworts am Ende der Übertragung kamen und am Anfang der Übetragung die letzten 8 Bits des Steuerworts übertragen wurden. Auf diese Weise habe ich ein Problem der Byte-Reihenfolge (Endianness) kennengelernt. Der Grund liegt darin, dass die Rechnerarchitektur und Betriebssystem meines Laptops und ESP32 Xtensa über verschiedene Byte-Reihenfolge verfügen, was ein Problem verursacht hat, indem man ein umgekehrtes Steuerwort bekommt. Ich habe das Problem in Programm gelöst und endlich konnte ich das Steuerwort richtig übertragen. 

Nachher sollte ich feststellen, wie man einen Schwellwert setzen muss, um Zimmerlautstärke von Industrie- und Gewerbelärm zu unterscheiden. Nach der Reihe von Versuchs, habe ich festgestellt, dass die $V_{ref}$ höher als 2.5V unmöglich ist für einen Mensch mit einem Schrei zu übersteigen. Obwohl man $V_{ref}$ bis 4.9V setzen darf, kann man tatsächlich bis 3.3V als $V_{ref}$ benutzen, weil die ganze Schaltung von 3,3V versorgt wird und am Ausgang des Mikrofons maximal 3,3V liegen können. Und obwohl die Werten bis 3.3V zur Verfügung stehen, kann man nur die Werte bis 2 - 2.5V als $V_{ref}$ durch SPI setzen, entweder es unmöglich wäre, den Schwellwert zu übersteigen. Tatsächlich liegen die Werte für Zimmerlautstärke zwischen 400 und 800 mV. Die merklich niedrigen Werten von 70 - 150 mV können sogar ein Flüstern erkennen und die Werten höhere als 1V sind geeignet, um sehr laute Geräusche zu erlauben.   

Damit wurde festgestellt, dass der Bereich der Schwellenwerte mit 2V begrenzt wird und der Arbeitspunkt bei 0,5V liegt, welcher als ein standardmäßiger Schwellenwert in jedem \textit{Noise Detector} benutzt wird. Nach dem Erwerben des \textit{Noise Detectors} kann Benutzer seinen eigenen Schwellwert setzen. Das manuelle Setzen des Schwellenwertes war ebenfalls eine Teilaufgabe meines Praktikums.

\subsubsection{Quellcode Beispiel}
\begin{lstlisting}
/***************************************************************************
* Sends a data to the Noise Click.
* Creates control word with a custom ref voltage
***************************************************************************/
void spi_to_noise_click_transmit_cmd(spi_device_handle_t spi, int vInNoiseClick){
	
	// creating the CW + Reference Voltage
	uint16_t data = ((COMMAND_SPI & 0xF) << 12) | (vInNoiseClick & 0xFFF);
	// solving the issue with big endian and little endian
	data = ((data & 0xFF) << 8) | ((data >> 8) & 0xFF);
	
	// calculating decimal value V_out, PIN 8, MCP4921, V_ref
	int V_out = ((V_REF_DAC * vInNoiseClick * GAIN_V_REF) / 4096) * 1000;
	int V_ref = (V_out * 11) / 13.2;
	
	printf("SPI: transmit decimal: %d\n", vInNoiseClick);
	printf("SPI: transmit HEX: %x\n", data);
	printf("V_out = %d mV\n", V_out);
	printf("V_ref = %d mV\n", V_ref);
	
	esp_err_t ret;
	spi_transaction_t t;
	memset(&t, 0, sizeof(t)); //Zero out the transaction
	t.length = 16;                  //length is in bits.
	t.rx_buffer = NULL;
	t.tx_buffer = &data;            //Data
	t.user = (void *) 1;
	
	// Transmit the CW
	ret = spi_device_transmit(spi, &t);
	assert(ret == ESP_OK);
	printf("Transmitted\n\n");
}
\end{lstlisting}

%=====================================================
\subsection{Hardware Interrupt bearbeiten}
\label{sec:main:interrupt}
Sobald der Schwellenwert der $V_{ref}$ überschritten wird, wird ein Hardware Interrupt am Pin \textit{Int} des \textit{Noise Clicks} erzeugt. Diesen Pin verknüpfte ich mit einem GPIO Pin des Mikrocontrollers, den ich jetzt für die Erkennung der Interrupts programmieren sollte. Dafür stehen die Funktionen des ESP32 Toolchains und FreeRTOS zur Verfügung, die mir erlaubten, die von \textit{Noise Clicks} erzeugten Interrupts zuerst in eine Queue (Schlange) zu sammeln und als eine logische 1 ins Interrupt Service Routine zu schicken. Wenn ein ankommender Interrupt aus der Queue abgewonnen wird, kann Programm dann entsprechen reagieren. Ich brauchte bei jedem Übersteigung des Schwellwerts ein Lämpchen (LED) und den Summer einzuschalten.  
\subsubsection{Schwierigkeiten und Lösung}
Sobald die Programmierung des Interrupts Service Routine erfolgreich abgeschlossen wurde, konnte man beobachten, wie oft die Interrupts ankommen und wie überhaupt die Übersteigung des Schwellenwerts aussieht. Es wurde festgestellt, dass bei menschlichen Gesprächen, wenn die Lautstärke höher als Schwellenwert ist, es zu eine Reihe von Interrupts kam. Der Grund liegt darin, dass ein Mensch nicht in der Lage ist, nach der ersten Meldung des \textit{Noise Detectors} seine Stimme sofort zu mäßigen und bräuchte einige Zeit, um sich zu beruhigen. Diese Tatsache hat mir gezeigt, dass nicht jeden ankommenden Interrupt (also Übersteigung des Schwellenwerts) das Einschalten des Lämpchens und Summers verursachen sollte. So wurde eine zusätzlichen Variable namens \textit{Threshold} hinzugefügt. Mit Hilfe von \textit{Threshold} kann der Benutzer die Empfindlichkeit einstellen. Je niedriger die Empfindlichkeit ist, desto mehr Hardware Interrupts werden ohne Softwaremeldung durchgelassen, was die Verwendung des \textit{Noise Detectors} in einem lauteren Raum zu ermöglichen sollte. Je höher die Empfindlichkeit ist, desto schneller wird die Softwaremeldung angezeigt. Dies sollte dem Zweck dienen, die leise Atmosphäre in einem Raum zu sichern.

 Es wurde eine Struktur namens \textit{TInterrupt} erstellt, die nebenbei die Zeit der Hardware Interrupt speichern soll.
 \begin{lstlisting}
 typedef struct {
 	int interruptNo;
 	int interruptVoltage;
 	int interruptTime;	
 } TInterrupt; 
\end{lstlisting}

Nach jedem folgenden Interrupt sollte einer Zeitunterschied berechnet werden, der von \textit{Threshold} abhängig ist. Je höhere Empfindlichkeit ist, desto kleiner ist Zeitunterschied, der die Hardware Interrupt in eine Schlange ohne Software Meldung sammeln erlaubt. Zusätzlich ändert sich anhand von \textit{Threshold} die erlaubte Länge der Schlange. Wenn es mehr Hardwareinterrupts als die erlaubte Länge der Schlange vor dem Ablauf eines erlaubten Zeitunterschieds ankommen wird, wird eine Softwaremeldung angezeigt, Lämpchen und Summer eingeschaltet. 
\begin{lstlisting}
int check_threshold(TQueue *q, TInterrupt *ir) {
....
	remove_outdated_interrupts(q, ir->interruptTime, T_TH3);
	
	int amountInterrupts = q_length(q);
	TInterrupt *tmpLastInt = q_getlast(q);
	
	// calculating the elapsed time
	double elapsedTime = ((double) (ir->interruptTime - tmpLastInt->interruptTime)) / CLOCKS_PER_SEC;

	if (amountInterrupts >= TH_AMOUNT 
	    && elapsedTime <= TH_TIME) {
		flag = 1;
	}
	
	// we did't exceed the amount of interrupts and time is still running
	else if (amountInterrupts < TH_AMOUNT 
	         && elapsedTime < TH_TIME) {
		flag = 0;
	}
...
}

\end{lstlisting}

\subsubsection{Quellcode Beispiel}
\begin{lstlisting}
/****************************************************************************
* GPIO Task
* Detects an interrupt from the ESP32 inner queue ->
* reads the voltage on the moment of interrupt
* sets the interrupt flag ->
* the RTOS tasks can detect the global variable (interrupt flag) and start perform
* their own interrupt routines. Separately tasks for each hardware and software task
* allow to switch on/off some functionality regarding to the client needs.
****************************************************************************/
void gpio_noise_interrupt_task(void* arg) {
uint32_t io_num;
while(1) {
	if(xQueueReceive(gpio_noise_interrupt_queue, &io_num, portMAX_DELAY) && io_num == GPIO_INPUT_INTERRUPT) {
		// get voltage from ADC
		detected_voltage = adc1_to_voltage(ADC1_TEST_CHANNEL, &characteristics);
		printf("%d mV\n", detected_voltage);
		printf("GPIO[%d]: #%d Interrupt\n", io_num, count);
		
		// add the new interrupt into the queue
		count++;
		detected_time = clock();
		printf("Detected time: %i\n", (int)detected_time);
		TInterrupt *new_interrupt = register_interrupt(count, detected_voltage, detected_time);
		q_add(queueInterrupt, new_interrupt);
			
		// check threshold and setting/resetting the interrupt flag
		detected_interrupt = check_threshold(queueInterrupt, new_interrupt);
	}
	else {
		// resetting interrupt flag if no interrupt occurs
		detected_interrupt = 0;
	}
}
}
\end{lstlisting}

%=====================================================
\subsection{LED ansteuern}
\label{sec:main:led}
Das Ein- und Ausschalten des Lämpchen gehört bei der Embedded Programmierung zum ersten Schritten, die man mit einem neuen Mikrocontroller überhaupt macht, um sich mit Toolchain, Programmiersprache und dem Aufbau des konkreten Mikrocontroller vertraut zu machen. 

Ich habe dafür eine \textit{FreeRTOS Task} entwickelt, die permanent läuft und in einer Schleife die Variable abfragt, die in Interrupt Service Routine gesetzt werden sollte. Wenn nach der Reihe der Hardwareinterrupts ein Ereignis \textit{Software Interrupt} vorkommt, wird die Variable mit 1 gesetzt und die entsprechenden \textit{FreeRTOS Tasks} können LED und Summer einschalten. 

Das LED Anschalten geschieht in ESP32 mit einem GPIO Pin, der auf 1 gesetzt werden soll. Das Ausschalten geschieht mit dem umgekehrten Setzung auf 0. 
\begin{lstlisting}
gpio_set_level(GPIO_OUTPUT_BLINK, 1);
\end{lstlisting}
Interessant war, dass es nicht ausreicht, einfach das Lämpchen einzuschalten und in ein Paar Sekunden wieder auszuschalten. Wenn \textit{FreeRTOS Task} für einige Zeit nichts macht (es gab keine Interrupt, also kein LED Steuerung), dann erscheint einen fatal Fehler bei ESP32:
\begin{lstlisting}
Guru Meditation Error: Core  0 panic'ed (Timeout on CPU1)
CPU halted.
\end{lstlisting}
ESP32 wurde so vom Hersteller programmiert, dass bei jedem fatal Fehler der Mikrocontroller einen Neustart kriegt. Wenn ein Fehler zufällig ist, stellt der Mikrocontroller sein Programm und die Aufgaben nach einigen Sekunden wieder her. Wenn der Fehler immer wieder vorkommt, kann der Mikrocontroller in eine Schleife geraten. Für meinen Anwendungsfall sollte ich einen Zeitverzug (engl. Delay) für jede \textit{FreeRTOS Task} vorsehen, die Task einfach für die kleinste Zeit verzögern kann. Damit wird es für CPU so aussehen, dass \textit{FreeRTOS Task} seine Aufgabe macht und nicht hängengeblieben ist und keinen Neustart notwendig ist.
 \begin{lstlisting}
vTaskDelay(10 / portTICK_RATE_MS);
 \end{lstlisting}
%=====================================================
\subsection{Die Frequenz durch PWM festlegen}
\label{sec:main:pwm}
PWM steht für (engl.) Pulse Width Modulation und auf Deutsch bedeutet das Pulsbreitenmodulation. Es ist ein bekanntes Verfahren im Embedded Systems, um LEDs und auch Motoren zu steuern. Es wurde bisher in meinem Studiengang nicht behandelt, obwohl es ein Standard heutzutage ist, der sehr leicht zu verwenden und zu verstehen ist. 

Die Steuerung des Summers ist mit PWM seht leicht und besteht im Prinzip aus zwei Schritten. Zuerst muss man die PWM initialisieren, indem man festlegt, welche Frequenz und welchen Arbeitszyklus man braucht. Außerdem muss man festlegen, welche PWM Einheit von zwei bei ESP32 vorhandenen man benutzen will.   
 \begin{lstlisting}
/**********************************************************************************
* PWM Config FOR NOISE ALARM INTERRUPT
**********************************************************************************/
void pwm_modul_config_noiseAlarm(mcpwm_config_t *pwm_config) {
	pwm_config->frequency = FREQUENCY_NOISE_ALARM;  // default no case frequency
	pwm_config->cmpr_a = DUTY_CYCLE;
	pwm_config->counter_mode = MCPWM_UP_COUNTER;
	pwm_config->duty_mode = MCPWM_DUTY_MODE_1;
	mcpwm_init(MCPWM_UNIT_0, MCPWM_TIMER_0, pwm_config);
	mcpwm_stop(MCPWM_UNIT_0, MCPWM_TIMER_0);
}
\end{lstlisting}

Die Steuerung durch PWM geschieht auch mit Hilfe eines GPIO Pins, den man als Ausgang programmieren muss. Wenn die entsprechende \textit{FreeRTOS Task} feststellt, dass ein Software Interrupt vorgekommen ist, gibt sie durch Ausgangspin einen Signal mit dem entsprechenden Arbeitszyklus und der Frequenz. Die zwei Parameter sorgen dafür, welchen Klang mit Summer erzeugt wird. 
\begin{lstlisting}
mcpwm_start(MCPWM_UNIT_0, MCPWM_TIMER_0);
vTaskDelay(INTERRUPT_DELAY / portTICK_RATE_MS);
mcpwm_stop(MCPWM_UNIT_0, MCPWM_TIMER_0);
\end{lstlisting}

Für die Zeit, in der \textit{FreeRTOS Task} keinen Summer steuert, sollte auch einen Zeitverzug vorgesehen werden. 

%=====================================================
\subsection{HTTPS Server und WiFi}
\label{sec:main:wifi}
Normalerweise ist es sehr leicht, den ESP32 Mikrocontroller mit einem WiFi Netzwerk zu verbinden, weil der Zweck des ESP32 eine leichte Anwendung in Bereich \textit{Interner der Dinge} ist. Jedoch muss der Benutzer dafür eine mobile Anwendung des ESP32-Herstellers verwenden, indem er die  Credentials des WiFI Netzwerks (SSID und Password) an den EPS32 übergeben kann. Ich wollte es vermeiden, dass unsere Kundin / unserer Kunde gezwungen wird, eine fremde und zusätzliche mobile Anwendung herunterladen und installieren müssen. Ich wollte es ermöglichen, die Einstellungen für WiFi Netzwerk direkt an den ESP32 übergeben. Außerdem sollten SSID und Password dauerhaft gespeichert werden, nach einem Ausschalten und Einschalten sollte ESP32 in der Lage sein, wieder die Verbindung herzustellen. 
\begin{figure}[!ht]
	\centering
	\fbox{\includegraphics[width=0.4\textwidth]{gfx/wifi.png}}
	\caption{HTTPS Server (Access Point mode)}
	\label{fig:wifi}
\end{figure}
Dafür wurde die externe Datei von Neil Kolban\footnote{https://github.com/nkolban/} verwendet. Seine cpp-Datei \textit{BootWiFi.cpp} ermöglichte mir genau das, was ich wollte. Das aber hat mich gezwungen, das ganze Projekt von der Programmiersprache C auf C++ umzustellen. 

Es gibt jetzt die folgende Möglichkeiten \textit{Noise Detector}  mit einem WiFi Netzwerk zu verbinden:
\begin{enumerate}
	\item Falls es immer noch keine Credetials für das WiFi Netzwerk gespeichert wurden, läuft \textit{Noise Detector} in diesem Fall als eigenständiger Zugangspunkt (Access Point mode). Das bedeutet, dass das ESP32 zu einem WiFi-Zugangspunkt wird, mit dem sich andere WLAN-Geräte verbinden können. Jetzt kann der Kunde sich über sein Handy oder ein anderes WLAN-Gerät mit dem ESP32 verbinden. Nach der Verbindung, können wir einen Browser öffnen. Auf der Browserseite werden wir nach der SSID und dem Passwort gefragt, die wir später verwenden möchten.Dies wird im \textit{Noise Detector} gespeichert. Anschließend verbindet sich das Gerät mit diesem Netzwerk.
	
	\item Wenn \textit{Noise Detector} in eine neue Umgebung gebracht wird, indem der zuvor gespeicherte Zugangspunkt nicht mehr zugänglich ist oder es einfach unmöglich ist, eine gespeicherte Verbindung herzustellen, wird \textit{Noise Detector} wieder zu einem Zugangspunkt und der Benutzer kann neue Informationen wie oben beschrieben eingeben.
	
	\item Wenn der Benutzer seinen Zugangspunkt ändert will, kann \textit{Noise Detector} einen GPIO-Pin beim Start abfragen. Wenn dieser Pin auf 1 hoch gesetzt wird (standard 0), kann dies den ESP32 wieder in Acces Point Modus versetzen.
\end{enumerate}

%=====================================================
\subsection{Publish und Subscribe durch MQTT Protokoll}
\label{sec:main:mqtt}
MQTT Protokoll kommt zum Einsatz meistens in den Bereichen \textit{Maschine zu Maschine} und \textit{Internet der Dinge} und ist sehr einfach für Menschen zu lesen und für Maschinen zu bearbeiten. Ich erinnere mich daran, dass im Modul \textit{Informatik 2} es am schwierigste war, die Aufgabe mit der Bearbeitung der XML-Datei zu erledigen. Es kam immer zu verschiedenen Fehler und die eigentliche Lösung ist nur in einer XML-Datei anwendbar. Falls sich die XML-Datei ändert, muss der Entwickler sein Programm wieder anpassen. 

Während der Übertragung durch MQTT Protokoll verwendet man JSON-Datei, in der alle Variables als entsprechende \textit{Methods} mit gesetzten \textit{Values} übertragt wird. Mit der Hilfe der C-Bibliothek \textit{cJSON.h} kann man sehr leicht eine JSON-Date erzeugen, die neue Werte hinzufügen, die ankommende JSON-Datei lesen und die notwendigen Werte erkennen und speichern. 
\begin{lstlisting}
void parseJsonCommand(char *json, command_holder_t *ch) {
...
	if (strcmp(method_name, "setVoltageValue") == 0) {
		param = cJSON_GetObjectItemCaseSensitive(monitor_json, "params");
	
		if (cJSON_IsString(param) && param->valuestring != NULL) {
			ch->method = METHOD_SET_VOLTAGE;
			ch->voltage = atoi(param->valuestring);
		}
	} else if (strcmp(method_name, "setSoundValue") == 0) {
		param = cJSON_GetObjectItemCaseSensitive(monitor_json, "params");
		if (cJSON_IsBool(param)) {
			ch->method = METHOD_SET_SOUND;
			ch->set_sound = cJSON_IsTrue(param);
		}
	} else if ...
}
\end{lstlisting}

\subsubsection{Lösung}
Eptecon hat eine eigene Webanwendung namens GlueLogics\footnote{http://gluelogics.com} basierend auf der Open Source IoT-Plattform ThingsBoard eingerichtet, um seine Geräte als \textit{Connected Devices} zu verwenden. Jedes Gerät wird bei GlueLogics als \textit{Connected Device} registriert und enthält damiteinen Token für Zugang (oder Zugriff). Mithilfe dieses Tokens und TLS-Protokolls (Transport Layer Security) geschieht eine Verbindung durch MQTT Protokoll zwischen \textit{Noise Detector} und GlueLogics. Nach der erfolgreichen Programmierung, wurde endlich die Verbindung hergestellt und die an die Anwendung übertragenen Werte erscheinen in \textit{Latest Telemetry} Fenster. 
\begin{figure}[h]
	\centering
	\fbox{\includegraphics[width=0.7\textwidth]{gfx/tele.png}}
	\caption{Latest Telemetry Fenster}
	\label{fig:tele}
\end{figure}

\begin{figure}[h]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{gfx/dashboard.png}}
	\caption{Noise Click Dashboard mit Widgets}
	\label{fig:dashboard}
\end{figure}

Jetzt kann man die gewünschte Variable wählen und sie auf einem Widget zeichnen lassen. Ich habe das Fenster (Abbildung \ref{fig:dashboard}) für \textit{Noise Detector} eingerichtet, in dem man sowohl den Summer und die LED ein- und ausschalten kann als auch die Einstellungen für den Summer und die LED überprüfen kann. Das wichtigste ist, natürlich, dass \textit{Noise Detector} jetzt einen festgestellten Lärmwert direkt an die Cloud in die GlueLogics Anwendung überträgt und in einem Zeitgraphen anzeigt. Mit den ausgeschalteten Summer und LED kann Administrator trotz beobachten, wie laut in Raum ist. 

 \subsubsection{Quellcode Beispiel}
\begin{lstlisting}
/*******************************************************************************
* MQTT Update JSON-File if Interrupt occurs
*******************************************************************************/
void mqtt_interrupt_task(void *arg){
	while(1) {
		if (detected_interrupt) {
			mqtt_update_json_voltage(detected_voltage);
			mqtt_update_json_battery(); 
			mqtt_publish(TOPIC2, mqtt_msg);
			detected_interrupt = 0; }
		else {
			detected_interrupt = 0;
			vTaskDelay(10 / portTICK_RATE_MS); }
	}
}
\end{lstlisting}

\begin{figure}[h]
	\centering
	\fbox{\includegraphics[width=0.7\textwidth]{gfx/subscribe.png}}
	\caption{MQTT Publish Beispiel}
	\label{fig:mqttpic}
\end{figure}

Die Abbildung \ref{fig:mqttpic} zeigt den Programmverlauf bei einem erfolgreichen MQTT Publish Ereignis.  

\newpage
%=====================================================
\subsection{Die Drucktasten und Entprellung}
\label{sec:main:switch}
\begin{wrapfigure}{l}{0.55\textwidth}
	\centering
	\fbox{\includegraphics[width=0.450\textwidth]{gfx/entp.png}}
	\caption{Die entprellten Drucktaste}
	\label{fig:entp}
\end{wrapfigure}
Während der Programmierung der Connectivity des \textit{Noise Clicks} kam es zur Notwendigkeit das Gerät mit einer Drucktaste zu versorgen, um es zu ermöglichen, die Credentials des jeweiligen WiFi-Netzwerks zu ändern. Ich habe auf das Problem der Tastenprellung gestoßen. Bei einmaligen Tastendruck registrierte mein Programm vielmals darauf. 

Ich fand es spannend, das Problem in der Programmiersprache C zu lösen, weil ich die Entprellung während meines Studiums kennengelernt habe und in VHDL schon erledigt habe. Es gab keine großen Schwierigkeiten, das Problem zu lösen und die Entprellung der Taste richtig zu programmieren.

%=====================================================
\subsection{Dauernde Speicherung in NVS}
\label{sec:main:nvm}
Um es dem Benutzer zu ermöglichen, seine Einstellungen am \textit{Noise Detector} sowohl übertragen als auch dauerhaft speichern, sollte non-volatile storage (NVS) library benutzt werden. NVS bedeutet aud Deutsch \textit{Nichtflüchtiger Speicher} und bezieht sich auf einen Flash-Speicher (ähnlich wie in USB Sticks), der Daten permanent speichern kann, wenn keine Stromversorgung vorhanden ist, und keine periodischen Aktualisierungen seiner Speicherdaten erfordert. ESP32 NVS arbeitet mit Schlüssel-Wert-Paaren. Schlüssel sind ASCII-Zeichenfolgen, die maximale Schlüssellänge beträgt 15 Zeichen. Werte können einen der folgenden Typen aufweisen:

\begin{itemize}
	\item integer types: $uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t$
	\item zero-terminated string
	\item variable length binary data (blob)
\end{itemize}

Für das Projekt \textit{Noise Detector} brauchte ich nur bestimmte Einstellungen speichern. Es wurde festgestellt, dass der Benutzer es wünschen könnte, sein \textit{Noise Detector} ohne einen Klang des Summers und/oder LED einzustellen. Zusätzlich möchte man den Schwellenwert $V_{ref}$ und die Empfindlichkeit $Threshold$ speichern. Die Möglichkeit die Einstellungen nach dem Neustart oder dem Ausschalten wiederherzustellen macht \textit{Noise Detector} zu einem fertigen Gerät, das dem Benutzer zur Verfügung steht. 
\begin{figure}[h]
	\centering
	\fbox{\includegraphics[width=0.7\textwidth]{gfx/nvs.png}}
	\caption{NVS Meldungen bei Neustart}
	\label{fig:nvsnvs}
\end{figure}
Abbildung \ref{fig:nvsnvs} zeigt, wie das Programmablauf bei Neustart aussieht. Nach GPIO Initialisierung wird Nichtflüchtiger Speicher geöffnet und die gespeicherte Werte entsprechend ihren Schlüsseln gesucht. Falls der jeweilige Schlüssel gesetzt ist und der Wert ausgelesen werden kann, wird den Wert als Variable in die entsprechenden Funktionen übertragen und die Funktionen werden ausgeführt. Zum Beispiel, falls  $V_{ref}$ von Benutzer eingestellt wurde, wird durch SPI Bus MOSI Pin der gespeicherte Wert am \textit{MCP4921/4922 12-Bit DAC}\footnote{http://ww1.microchip.com/downloads/en/devicedoc/21897b.pdf} übertragt. Damit wird bei jedem Neustart den gespeicherte Schwellenwert wiederherstellt und \textit{Noise Click} wird immer mit den Einstellungen des Benutzers starten. Falls es keine Spannung $V_{ref}$ gespeichert wurde (also existiert keinen Schlüssel namens {VARIABLE SET VOLTAGE}) wird ein standardmäßiger Schwellenwert 0.5V durch SPI übertragen. Damit können wir sicherstellen, dass im Fall eines Fehlers \textit{Noise Detector} seine standardmäßigen Einstellungen wiederherstellt wird. 
\subsubsection{Quellcode Beispiel}
\begin{lstlisting}
switch (varType) {
	case NO_VARIABLE:
		break;
	case VARIABLE_SET_VOLTAGE:
		printf("Updating reference voltage in NVS ... ");
		err = nvs_set_i16(handle, "refVoltage", value);
		break;
	case VARIABLE_SET_SOUND:
		printf("Reading reference voltage from NVS ...");
		err = nvs_set_i16(handle, "buzzer", value);
		break;
	case VARIABLE_SET_LED:
		printf("Reading reference voltage from NVS ...");
		err = nvs_set_i16(handle, "led", value);
		break;
	case VARIABLE_SET_THRESHOLD:
		printf("Reading reference voltage from NVS ...");
		err = nvs_set_i16(handle, "threshold", value);
		break;
	default:
		break;
}
\end{lstlisting}
%=====================================================
\subsection{PCB Design und Aufbau der Hardware}
\label{sec:main:pcb}
Als ich mit der Programmierung und Testen fertig war, kam es endlich zu einem voll unbekannten und interessanten Aufgabe: Eine Leiterplatte zu bauen. Dafür habe ich die Software \textit{EAGLE CAD}\footnote{https://www.autodesk.com/products/eagle/overview} verwendet. Bevor ich beginnen konnte, Leiterbahnen und andere Dinge zu zeichnen, musste ich wissen, welche Schaltung ich bauen möchte. Ich musste also Schaltplan für meine Schaltung entwerfen.

\begin{figure}[ht]
	\centering
	\fbox{\includegraphics[width=0.9\textwidth]{gfx/buzzer.png}}
	\caption{Messung von Summer}
	\label{fig:buzzer}
\end{figure}

Dafür habe ich die alle Datenblätter von \textit{ESP32 Mikrocontroller, Noise Click und Buzz Click } wieder durchgelesen und dann alle benötigten Komponenten (Kondensatoren, Widerstände, Summer, Mikrofon u.s.w) zu meinem Schaltplan hinzugefügt. Für viele Sachen kann man schon existierende Bibliotheken von Herstellern benutzen. Ich musste nur eine lbr-Datei für Summer selbst entwerfen, weil diese im EAGLE Format noch nicht gab. Während des Entwurfs sollte ich den Summer genau Vermessen (Abbildung \ref{fig:buzzer}), damit er auf Leitplatine richtig positioniert werden kann. 

Dann sollte man genau alle GPIO Pins, die in Projekt verwendet wurden, mit entsprechenden Ein- und Ausgängen anderer Bauteile zu verknüpfen. Hier muss man immer aufpassen und alles richtig machen, damit die Leitplatine nach der Herstellung und Löten funktioniert. Abbildung \ref{fig:schematic} zeigt den fertigen Schaltplan in Eagle Software. Es ist ESP32 zu sehen, der schon mit allen Bauteilen verbunden ist.
\begin{figure}[ht]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{gfx/Schematic_MC_Charger_Buzzer.png}}
	\caption{Schaltplan des Noise Clicks}
	\label{fig:schematic}
\end{figure}

Nach der Fertigung des Schaltplans, fängt man mit dem Design der Leiterplatte an. Ich musste mein Schaltbild in eine Zeichnung meiner Leiterplatte übertragen. Man muss sich viele Gedanken darüber machen und viele Sachen während des PCB Designs überlegen. Zum Beispiel, wie wir die Leiterplatte in ein Gehäuse stecken werden. Welche Bauteile wie platziert werden müssen, um in unsere festgelegte Leiterplattengröße zu passen. Wenn alle Fragen geklärt wurden, konnte man mit dem PCB Design weitermachen. 
\begin{figure}[ht]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{gfx/platstart.jpg}}
	\caption{Leiterplatte des Noise Clicks}
	\label{fig:platestart}
\end{figure}
\begin{figure}[ht]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{gfx/platdone.jpg}}
	\caption{3D Visualisation}
	\label{fig:platedone}
\end{figure}

Ich habe die Bauteile wie Kondensatoren und Widerstände entsprechend der BOM-Datei (BOM bedeutet Bill Of Materials - oder auf Deutsch: Stückliste) auf der Mouser.de\footnote{https://www.mouser.de/} Website zum Bestellung ausgewählt. BOM-Datei wird automatisch aus dem Schaltplan von Eagle erstellt. Die Datei ist wie eine Einkaufsliste für elektronisches Design. Sie enthält alle Bauteile, die für die Fertigstellung PCB erforderlich sind. Aber statt einer allgemeinen Einkaufsliste mit einem Ein-Wort-Wert für einen Artikel enthält ein Artikel in der BOM-Datei viel Information, die es erleichtert, die richtigen Bauteile zu identifizieren und zu kaufen.

\begin{figure}[ht]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{gfx/bom.png}}
	\caption{BOM Datei des Noise Clicks: Kondensatoren}
	\label{fig:bom}
\end{figure}

Zum Schluss meines Praktikums wurde die Leiterplatte bei einem spezialisierten Fertiger bestellt. Die Fertigung sollte noch zwei Wochen nach dem Ablauf meines Praktikums dauern. Das Projekt \textit{Noise Detector} wurde voll programmiert und eine Leitplatine dafür entwickelt. 
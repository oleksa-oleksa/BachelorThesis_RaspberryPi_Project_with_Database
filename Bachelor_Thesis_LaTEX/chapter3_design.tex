% !TeX spellcheck = de_DE
\chapter{Systemdesign}
\label{sec:design}
Die Softwareentwicklung beginnt mit einer Beschreibung der Bedürfnisse und ihrer Analyse. Je genauer und korrekter die Beschreibung der Softwareanforderungen und deren Analyse ist, desto einfacher ist es, alle nachfolgenden Schritte abzuschließen. Das Hauptproblem in dieser Phase ist der Unterschied in den Ansichten des Kunden (in dem Fall der vorliegenden Abschlussarbeit sind die Kunden die PSE-Labor Mitarbeiter) und des Entwicklers (die Autorin der Abschlussarbeit). Es wurde auch die Entscheidung getroffen, mit welchen Hardware ist die Aufgabestellung zu implementieren. Jedoch während der Entwicklung der Register-Client (der einer von drei Bestandsteilen der Software, an dem ein RFID-Leser angeschlossen werden muss), wurde schließlich ein RFID-Leser gewechselt. Der Fall ist im Kapitel \ref{sec:register_client:install_rfid} nachzulesen. Im Rahmen der Analyse und des Systemdesigns wurden die Struktur und Zusammenhänge der Elemente des zu entwickelnden Systems untersucht. Das Ergebnis dieser Untersuchung enthält genügend Informationen, um das System zu implementieren und ist unten in folgenden Kapitels detailliert beschrieben. 

\section{User Stories}
\label{sec:design:user_stories}
Zuerst wurden die User Stories erstellt, die eine diskutierte Darstellung der Absicht (Endbenutzer muss/will so etwas tun) zeigen können. Es ist mithilfe der User Stories zu klären, was die zu entwickelnde Datenbank leisten soll. Es wird auf die Frage konzentriert, welche Daten in der Datenbank gespeichert werden sollen. 
Der Text der User Story selbst sollte die Rolle / Aktionen des Benutzers im System, seine Bedürfnisse und den Gewinn erläutern, den der Benutzer nach dem Auftreten der Story erhält. Zum Beispiel: Wie \textit{<Benutzerrolle / Charakter>, ich <möchte etwas bekommen>, <für diesen und jenen Zweck>}. Während des Schreibens der User Story wurden zwei Gruppe von Stakeholders definiert: die Studierende (Beuth Studentinnen und Studenten) und der Admin (PSE-Labor Mitarbeitern). Es wurden die folgenden User Stories erstellt, die später während der Entwicklungsphase implementiert wurden:
\begin{itemize}
	\itemsep-1.2em 
	\item As a student, I want \textbf{to loan a board} so I can work at lab
	\item As a student, I want \textbf{to loan a board} so I can work at home
	\item As a student, I want \textbf{to list boards assigned to me} so that I am sure I to return
	\item As a student, I want \textbf{to return a board from lab work} so that I can loan again
	\item As a student, I want \textbf{to return a board from home work} so that I can loan again
	\item As a student, I want \textbf{to initiate session} so I can loan a board
	\item As a lab admin, I want \textbf{to mark a board} so it can be loaned for home or for lab
	\item As a lab admin, I want \textbf{to terminal session} with timeout so that students can use the loan station
	\item As a lab admin, I want \textbf{to block a student} so that they won't be able to loan a board
	\item As a lab admin, I want \textbf{to see all students} registered on the course so that I can manage their profiles
	\item As a lab admin, I want \textbf{to see all loaned boards} so that I can know their expected return date
	\item As a lab admin, I want \textbf{to register students} so that they are able to loan boards
	\item As a lab admin, I want \textbf{to register new boards} so that thay can be loaned
	\item As a lab admin, I want \textbf{to delete student's record} when semester ends so that they are not stored anymore in database
\end{itemize}


\section{Anforderungen}
\label{sec:design:req}
Während die meisten neuen Funktionen mithilfe der User Stories aus Anwendersicht definiert werden sollten, ist dies nicht immer machbar oder sogar hilfreich, wenn es zu Sicherheitsfunktionen oder Infrastrukturanforderungen kommt, die nicht kundenorientiert sind. Es gibt zwei Arten von Anforderungen: funktionale Anforderung und nichtfunktionale Anforderungen. Während der Analysephase wurden die beiden Arten von Anforderungen definiert. 

\subsection{Funktionale Anforderungen}
Eine funktionale Anforderung beschreibt, was ein Softwaresystem tun sollte. Es werden die folgenden funktionalen Anforderungen definiert:
\label{sec:design:req:func}
\begin{itemize}
	\itemsep-1.2em 
	\item The background color for all windows in the application will be white and have a hexadecimal RGB color value of 0x0000FF.
	\item The colors of design guidelines of Beuth Hochschule will be used.
	\item The software automatically validates whether a student is able to loan a board for a homework.
	\item The software automatically shows the information about boards that student already loaned.
	\item Student will see their name after they scanned their valid student card.
	\item Student will see board's number after they scanned a Raspberry Board.
	\item If student can not loan a board they will see an information message on a display.
	\item If a student can not loan a board the session should be terminated
	\item If an error during the loan proccess is occured the student will see datailed information so they can later talk with an admin about theis issue.
	\item Error states will be marked with red color on the page
	\item Succeeded states will be marked with a green color on the page
\end{itemize}

\subsection{Nichtfunktionale Anforderungen}
Nichtfunktionale Anforderungen bestimmen nicht die Funktionen, sondern die Eigenschaften des Systems: Leistung, Zuverlässigkeit, Verfügbarkeit, Skalierbarkeit und eine Reihe anderer Parameter, die das Systems einschränken und verbessern sollen. 
\label{sec:design:req:non-func}
\begin{itemize}
	\itemsep-1.2em 
	\item The Server has to be implemented using a modern Python web framework Django.
	\item The user Interfaces (frontend) shall be implemented as HTML pages with dynamic content inside based on Django Templates.
	\item The admin views must require authorization. A view decorated with this function will be executed normally only if the logged user has admin rights.
	\item The SQLite rational database will be used in order to store students, boards and loan records
	\item For terminating the session automatically after timeout the command line application (CLI) will be implemented using python and will be run on the server.
	\item Users must use for the initial login their student card. Moreover, every next login will be done with the same card. 
	\item Students never allowed to loan home board longer than 1 week (7 calendar days). Such attempt should be reported to the security administrator.
	\item Students never allowed to loan lab board longer than 120 minutes. An the end of the exercise admnistrator should be notified if the board was not returned.
	\item Loan process can not be started if a student was not properly registered on the course
	\item Every unsuccessful attempt by a user to loan/return an item shall be recorded on an audit trail.
	\item Only one active session is allowed for loan/return process. No multi-user mode is intended
	\item If the currect session is inactive longer longer than 180s the session will be terminated and should be restarted
	\item The actions made on RFID-Reader should be displayed on the screen with an acceptable delay for a humans (less then 5 seconds)
\end{itemize}

Während die User Story selbst die Verbindung zwischen der menschlichen Wahrnehmung und der technischen Umsetzung ist, können mithilfe der Anforderungen die Betriebsfunktionen und Einschränkungen des Systems beschrieben werden, die seine Funktionalität verbessern.

\section{Systemmodell mit UML}
\label{sec:design:uml}

\section{Komponentendiagramm}
\label{sec:design:uml:uml_component}

\subsection{Klassendiagramm}
\label{sec:design:uml:class}
Für das Systemarchitektur wird das UML-Klassendiagramm entwickelt, das einen Überblick über ein Softwaresystem bietet, indem Klassen, Attribute, Operationen und deren Beziehungen angezeigt werden. Dieses Diagramm enthält den Klassennamen, die Attribute und die Operation in separaten festgelegten Fächern. In der Entwurfsphase wird es festgelegt, welche Klassen das System benötigt wird. Die festgestellte Klassen werden weiter nicht wie üblichen Python-Klassen implementieren, jedoch wie eine Django Modelle direkt zum Erzeugen der Datenbank verwendet. 

\subsection{Anwendungsfalldiagramm}
\label{sec:design:uml:use_cases}
Während der Analyse der Systemanforderungen haben wir festgestellt, dass die Software aus vier zentralen Anwendungsfällen bestehen sollte. Diese sind: Die Ausleihe des Lab-Loan Boards, die Rückgabe des Lab-Loan Boards, die des Ausleihe des Home-Loan Boards, die Rückgabe des Home-Loan Boards. Jeder von diesen Anwendungsfälle kann erfolgreich oder mit dem Fehler beendet werden.  

\section{Systemarchitektur}
\label{sec:design:arch}
\begin{figure}
	\centering
	\fbox{\includegraphics[width=1\textwidth]{gfx/Class_Diagram.png}}
	\caption{UML Klassendiagramm.}
	\label{fig:class}
\end{figure}
Die Architektur besteht aus den grundlegenden Beschreibungen (Ansichten),  die zeigen, aus welchen grundlegenden Teilen (Komponenten, Modulen, Layouts usw.) das System besteht und wie diese Beschreibungen zusammenhängen. Das System aus Sicht des Benutzers umfasst Artefakte in Bezug auf praktische Anwendungsphasen, Szenarien und Workflows. Das System aus Sicht des Managers oder Kunden umfasst Artefakte, die die Grenze zwischen dem System und seiner Umgebung definieren, grundlegende Funktionen und Verhaltensweisen des Systems, sowie interne und externe Benutzer. Endlich das System aus Sicht der Designer definiert physische Sicht. Dies umfasst Artefakte, die die physische Grenze des Systems, Komponenten, ihre Interaktionen zwischen interne Datenbanken und Datenstrukturen und die bei seiner Entwicklung verwendeten Standards definieren.

Während des Entwurfs, der Entwicklung und der Modernisierung eines Softwaresystems erfordert die „Reihe von Entscheidungen über seine Organisation“ (Architektur) eine ständige Diskussion mit allen Beteiligten des Projekts. Auch hier ist es wichtig, dass jeder die gleiche Vorstellung über das System von sich hat. 

Es ist offensichtlich, dass für die effektive Präsentation architektonischer Lösungen für alle interessierten Parteien eine bestimmte Methode erforderlich ist, die es ermöglicht, ihre Essenz einem möglichst breiten Personenkreis auf zugängliche, aber ausreichend detaillierte Weise zu vermitteln. Ein Klassendiagramm kann auf diese Weise dienen. Das Klassendiagramm definiert die Objekttypen im System und die verschiedenen Arten von Beziehungen, die zwischen ihnen bestehen. Es bietet eine allgemeine Ansicht einer Anwendung. Diese Modellierungsmethode kann mit fast allen objektorientierten Methoden ausgeführt werden. Das Klassendiagramm erklärt, was sind die Komponenten des Systems und wo sollen wir die Einkapselungsbarrieren platzieren. Welche Entscheidungen sind innerhalb von Komponenten zu verbergen, damit sie geändert werden können, ohne den Rest des Systems zu beeinträchtigen. Wie und was müssen die Komponenten wirklich kommunizieren. Zum Beispiel, was sollte in den Schnittstellen sein oder welches Protokoll sollte verwendet werden? Auf der Abbildung \ref{fig:class} den Zusammenhang zwischen die drei Bestandsteilen (Register-Client, Server und Display-Client) mit den Einkapselungsbarrieren zu sehen. Da es schon während der Besprechung der Aufgabestellung mit den PSE-Labor Mitbietern für eine Entwicklung mit Django Framework entschieden wurde, wird es im Klassendiagramm schon zu sehen. Die Klassen wurden am Anfang als die Django Modele geplant, die in einer SQLite Datenbank verwaltet werden. Dann muss z.B. kein Primärschlüssel in Datenbankdesign definiert werden, da es von Django eine Primärschlüssel erzeugt wird und Entwickler darüber nicht kümmern muss. Die drei Komponenten werden miteinander über HTTP-Protokoll kommunizieren. Es wird mithilfe API-Endpunkt geschehen, an dem eine Verbindung mit den drei Bestandteilen der Softwareprogramm herstellt wird. An den API-Endpunkt werden Informationsanforderungen von einer Webanwendung einem Webserver geschickt die Antwort empfangen.

\section{Endliche Zustandsmaschine}
\label{sec:design:fsm}
